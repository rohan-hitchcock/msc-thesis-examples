from sage.all import PolynomialRing, QQ, Rational 
from math import prod
import numpy as np

def polynomial_division(f, ts, careful=True): 
    """ 
        The multivariate polynomial division algorithm from Theorem 2.3.3 in
        Ideals, Varieties and Algorithms by Cox, Little and O'Shea

        Args:
            f: the polynomial to divide, an element of a Sage PolynomialRing
            ts: a list of non-constant divisors, a list of elements of a Sage PolynomialRing
            careful: if set to True then verifies the computed value is correct, throwing 
            an exception otherwise

        Returns: 
            A tuple (r, qs) such that f == r + sum(q * t for (q, t) in zip(qs, ts))
            and the other conditions of CLO Theorem 2.3.3 are satisfied.
    """

    if any (t.is_constant() for t in ts):
        raise NotImplementedError("Division by non-constant polynomials is not supported.")

    qs = [0] * len(ts)
    r = 0
    p = f
    
    while not p.is_zero():

        division_occurred = False
        i = 0
        while i < len(ts) and not division_occurred:

            lt_t = ts[i].lt()
            lt_p = p.lt()
            
            if lt_t.divides(lt_p):
                qs[i] += lt_p // lt_t
                p -= (lt_p // lt_t) * ts[i]
                division_occurred = True

            else: 
                i += 1
            
        if not division_occurred: 
            r += lt_p
            p -= lt_p

    if careful:
        assert f == r + sum(q * t for (q, t) in zip(qs, ts))

    return (r, qs)


def multipow(ts, us, strict=True):
    """ 
        Computes sequences to the power of multi-indices: t^u := t_1 ^{u_1} ... t_n ^{u_n}.

        Args:
            ts: a sequence of things which can be raised to any us[i], and which can 
            be multiplied together
            us: a sequence of things which make sense to use as a power of any ts[i]
            strict: if True, this function will throw an exception if len(ts) != len(us)

        Returns: 
            The product of all ts[i] ** us[i]
    """
    if strict:
        assert len(ts) == len(us)

    return prod(t ** u for t, u in zip(ts, us))


def generate_series_expansion(f, ts, gs, coeffs, careful=True): 
    """ An implementation of Algorithm 3.3.7. Generates coefficients in the 
        unique I-adic series expansion of f in terms of ts, where I is the ideal generated by 
        elements of the sequence ts (See Lemma 3.3.6). 
        
        In general this series expansion of f may have infinitely many terms, so 
        this generator may never end.
        
        Args:
            f: the polynomial as an element of a Sage PolynomialRing
            ts: a quasi-regular sequence of polynomials 
            gs: a Groebner basis for the ideal generated by ts
            coeffs: coefficient polynomials relating gs to ts, such that 
                `all (g == sum(c * t for c, t in zip(cs, ts)) for g, cs in zip(gs, coeffs))`
                is True 
            careful: if set to True, continually verifies the intermediate series 
                expansion is equal to f, throwing an exception if it is not. This 
                involves cacheing all previously generated terms.
                
        Yields:
            A tuple `(u, r)` where `r` is a polynomial and u is a vector of natural numbers.
            The polynomial r is the coefficient of `multipow(ts, u)` in the I-adic 
            series expansion of `f`. These tuples are generated so that the 
            sequence of `sum(u)` is non-decreasing.
    """

    qs = [(np.zeros(len(ts)), f)]

    coeffs = np.array(coeffs) # so we can take the transpose

    # if we are verifying the calculation then we need to keep track of the 
    # previously generated terms.
    if careful:
        rs = [] 

    while len(qs) > 0:

        if careful: 
            assert f == sum(r * multipow(ts, u) for u, r in rs) + sum(q * multipow(ts, u) for u, q in qs)

        qs_new = []

        for (u, q) in qs:

            (r, ps) = polynomial_division(q, gs)

            yield (u, r)

            if careful:
                rs.append((u, r))

            new_ps = (sum(p * c for p, c in zip(ps, cs)) for cs in coeffs.transpose())

            if careful:
                # in this case we need to iterate through new_ps more than once, 
                # so convert it to a list
                new_ps = list(new_ps)

                assert q == r + sum (p * t for p, t in zip(new_ps, ts))

            for i, p in enumerate(new_ps):

                if p != 0:
                    # create the i-th standard basis vector
                    e = np.zeros(len(ts))
                    e[i] += 1

                    qs_new.append((u + e, p)) 

                qs = collect_coefficients(qs_new)


def collect_coefficients(qs):
    """
        A helper function for `generate_series_expansion`. Collects elements of a
        set of coefficient polynomials so that there is at most one coefficient 
        for each index.

        Args:
            qs: an iterable containing elements of the form (u, q) where q is 
                a polynomial and u is some kind of index identifying the term q 
                is the coefficient of. In the context of `generate_series_expansion`
                q is the coefficient of `multipow(ts, u)`.

        Returns: 
            A list with elements of the form (u, q) where each u appears exactly 
            once and all q != 0 
    """

    qs_collected = dict()
    for u, q in qs:
        if tuple(u) not in qs_collected:
            qs_collected[tuple(u)] = q
        else:
            qs_collected[tuple(u)] += q

    return [(np.array(u), q) for u, q in qs_collected.items() if q != 0]


# Examples --------------------------------------------------------------------

def pretty_print_series_coefficients(f, ts, gs, coeffs):
    """ 
        Prints output of `generate_series_expansion(f, ts, gs, coeffs)` in a nice 
        way.        

        Returns: None (prints output)
    """
    
    print(f"\nSeries expansion for f == {f} in terms of t = {tuple(ts)}")
    print(f"f == ", end="")

    for i, (u, q) in enumerate(generate_series_expansion(f, ts, gs, coeffs)):

        # formatting
        if i == 0:
            print("\n\t", end="")
        else:
            print("\n\t+ ", end="")
        

        t_power_string = sequence_power_to_string(u)

        s = f"({q}){t_power_string}" if t_power_string else str(q)


        print(s, end="")


        if i > 0 and i % 10 == 0: 
            if input("\n\nContinue? (Y/N): ").lower() != 'y':
                break
        
    print()


def sequence_power_to_string(us):
    """ Helper function for examples to generate nice looking output."""
    s = ""

    for i, u in enumerate(us):
        if u != 0:
            s += f"*t{i}^{int(u)}" 
    return s[1:]


def run_example344():
    """ Runs Example 3.4.4. This example is in the ring QQ[x, y]. We compute 
        the series expansion of the polynomial x in terms of the sequence 
        t = (y^2 + 1, xy + 1), followed by a randomly generated polynomial of
        degree 10. These series expansion may be infinite, so the user will 
        be prompted to either continue to generate output or 

        Returns: None (prints output).
    """

    R = PolynomialRing(QQ, ['x', 'y'], order='lex')
    x, y = R.gens()

    ts = [y**2 + 1, x * y + 1]
    I = R.ideal(ts)

    # use .reduced() to ensure a reduced grobner basis: some Sage algorithms do 
    # not return this
    gs = I.groebner_basis().reduced()

    coeffs = [
        [x, -y], 
        [Rational(1), Rational(0)]   
    ]

    assert all (g == sum(c * t for c, t in zip(cs, ts)) for g, cs in zip(gs, coeffs))


    

    print(f"Example 3.4.4 ------------------------------------------------------------------")
    f = x
    pretty_print_series_coefficients(f, ts, gs, coeffs)

    f = R.random_element(degree=10)
    pretty_print_series_coefficients(f, ts, gs, coeffs)


def run_example335():

    R = PolynomialRing(QQ, ['x', 'y', 'z'], order='lex')
    x, y, z = R.gens()

    ts = [3*x**2 + y**3, 3*x*y**2, 2 * z]
    I = R.ideal(ts)

    # use .reduced() to ensure a reduced grobner basis: some Sage algorithms do 
    # not return this
    gs = I.groebner_basis().reduced()

    coeffs = [
        [Rational(1/3), Rational(0), Rational(0)], 
        [Rational(0), Rational(1/3), Rational(0)],
        [y**2, -x, Rational(0)], 
        [Rational(0), Rational(0), Rational(1/2)]    
    ]

    assert all (g == sum(c * t for c, t in zip(cs, ts)) for g, cs in zip(gs, coeffs))

    print(f"Example 3.4.5 ------------------------------------------------------------------")

    f = R.random_element(degree=10)
    pretty_print_series_coefficients(f, ts, gs, coeffs)

def run_example_Dn(n=4):

    R = PolynomialRing(QQ, ['x', 'y', 'z'], order='lex')
    x, y, z = R.gens()

    ts = [2*x*y, x ** 2 + 3 * y ** (n-2), 2 * z]
    I = R.ideal(ts)

    # use .reduced() to ensure a reduced grobner basis: some Sage algorithms do 
    # not return this
    gs = I.groebner_basis().reduced()


    coeffs = [
            [Rational(0), Rational(1), Rational(0)],
            [Rational(1/2), Rational(0), Rational(0)],
            [Rational(-1/6) * x, Rational(1/3) * y, Rational(0)], 
            [Rational(0), Rational(0), Rational(1/2)]       
        ]
    

    print(f"Example with D{n} --------------------------------------------------------------")
    f = R.random_element(degree=10)
    pretty_print_series_coefficients(f, ts, gs, coeffs)



if __name__ == "__main__": 
    
    run_example344()
    run_example335()
    run_example_Dn()
